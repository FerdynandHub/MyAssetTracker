// ================================
// Dastrack - Google Apps Script Backend
// Sheet1 = current data (update only)
// Sheet2 = history log (append only)
// UpdateRequests = pending approval requests
// ================================

const SPREADSHEET_ID = '1uHTV9NX4mTrRGd-VTB_aIzMtfkuCUSu9-8JkfVvs2po';
const SHEET_NAME = 'Sheet1';
const HISTORY_SHEET_NAME = 'Sheet2';

// ---------- ENTRY POINTS ----------

function doGet(e) {
  try {
    const action = e.parameter.action;

    switch (action) {
      case 'getAssets':
        return getAssets();
      case 'getAsset':
        return getAssetById(e.parameter.id);
      case 'getCategories':
        return getCategories();
      case 'getPendingRequests':
        return getPendingRequests();
      default:
        return json({ error: 'Invalid action' });
    }
  } catch (err) {
    return json({ error: err.toString() });
  }
}

function doPost(e) {
  try {
    const body = JSON.parse(e.postData.contents);
    const action = body.action;

    switch (action) {
      case 'updateAsset':
        return updateAsset(body.id, body.updates);
      case 'batchUpdateAssets':
        return batchUpdateAssets(body.ids, body.updates);
      case 'submitUpdateRequest':
        return submitUpdateRequest(body);
      case 'approveRequest':
        return approveRequest(body);
      case 'rejectRequest':
        return rejectRequest(body);
      default:
        return json({ error: 'Invalid action' });
    }
  } catch (err) {
    return json({ error: err.toString() });
  }
}

// ---------- HELPERS ----------

function getSheet() {
  return SpreadsheetApp
    .openById(SPREADSHEET_ID)
    .getSheetByName(SHEET_NAME);
}

function getHistorySheet() {
  return SpreadsheetApp
    .openById(SPREADSHEET_ID)
    .getSheetByName(HISTORY_SHEET_NAME);
}

function getRequestSheet() {
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  let sheet = ss.getSheetByName('UpdateRequests');
  
  if (!sheet) {
    sheet = ss.insertSheet('UpdateRequests');
    sheet.appendRow(['requestId', 'ids', 'updates', 'requestedBy', 'timestamp', 'status', 'type']);
  }
  
  return sheet;
}

function json(data) {
  return ContentService
    .createTextOutput(JSON.stringify(data))
    .setMimeType(ContentService.MimeType.JSON);
}

function nowJakarta() {
  return Utilities.formatDate(
    new Date(),
    "Asia/Jakarta",
    "yyyy-MM-dd HH:mm:ss"
  );
}

function formatLastUpdated(value) {
  if (!value) return value;

  const d = (value instanceof Date)
    ? value
    : new Date(value);

  if (isNaN(d)) return value;

  return Utilities.formatDate(
    d,
    "Asia/Jakarta",
    "yyyy-MM-dd HH:mm:ss"
  );
}

// ---------- READ ----------

function getAssets() {
  const sheet = getSheet();
  const data = sheet.getDataRange().getValues();
  const headers = data[0];
  const assets = [];

  const lastUpdatedIndex = headers.indexOf('lastUpdated');

  for (let i = 1; i < data.length; i++) {
    const obj = {};

    headers.forEach((h, j) => {
      if (j === lastUpdatedIndex) {
        obj[h] = formatLastUpdated(data[i][j]);
      } else {
        obj[h] = data[i][j];
      }
    });

    assets.push(obj);
  }

  return json(assets);
}

function getAssetById(id) {
  if (!id) return json(null);

  const sheet = getSheet();
  const data = sheet.getDataRange().getValues();
  const headers = data[0];

  const idIndex = headers.indexOf('id');
  const lastUpdatedIndex = headers.indexOf('lastUpdated');

  if (idIndex === -1) {
    return json({ error: 'id column not found' });
  }

  for (let i = 1; i < data.length; i++) {
    if (String(data[i][idIndex]) === String(id)) {
      const asset = {};

      headers.forEach((h, j) => {
        if (j === lastUpdatedIndex) {
          asset[h] = formatLastUpdated(data[i][j]);
        } else {
          asset[h] = data[i][j];
        }
      });

      return json(asset);
    }
  }

  return json(null);
}

function getCategories() {
  const sheet = getSheet();
  const data = sheet.getDataRange().getValues();
  const headers = data[0];
  const categoryIndex = headers.indexOf('category');

  if (categoryIndex === -1) return json([]);

  const categories = [];

  for (let i = 1; i < data.length; i++) {
    const value = data[i][categoryIndex];
    if (value && !categories.includes(value)) {
      categories.push(value);
    }
  }

  return json(categories);
}

// ---------- HISTORY ----------

function appendHistory(headers, originalRow, updates) {
  const historySheet = getHistorySheet();

  const snapshot = headers.map((h, index) => {
    if (h === 'lastUpdated') {
      return nowJakarta();
    }
    if (updates.hasOwnProperty(h)) {
      return updates[h];
    }
    return originalRow[index];
  });

  historySheet.appendRow(snapshot);
}

// ---------- UPDATE ----------

function updateAsset(id, updates) {
  if (!id || !updates) {
    return json({ error: 'Invalid payload' });
  }

  const sheet = getSheet();
  const data = sheet.getDataRange().getValues();
  const headers = data[0];
  const idIndex = headers.indexOf('id');

  if (idIndex === -1) {
    return json({ error: 'id column not found' });
  }

  for (let i = 1; i < data.length; i++) {
    if (String(data[i][idIndex]) === String(id)) {

      Object.keys(updates).forEach(key => {
        const col = headers.indexOf(key);
        if (col !== -1) {
          sheet.getRange(i + 1, col + 1).setValue(updates[key]);
        }
      });

      const lastUpdatedIndex = headers.indexOf('lastUpdated');
      if (lastUpdatedIndex !== -1) {
        sheet.getRange(i + 1, lastUpdatedIndex + 1)
          .setValue(nowJakarta());
      }

      appendHistory(headers, data[i], updates);

      return json({ success: true });
    }
  }

  return json({ error: 'Asset not found' });
}

function batchUpdateAssets(ids, updates) {
  if (!Array.isArray(ids) || !updates) {
    return json({ error: 'Invalid payload' });
  }

  const sheet = getSheet();
  const data = sheet.getDataRange().getValues();
  const headers = data[0];
  const idIndex = headers.indexOf('id');

  if (idIndex === -1) {
    return json({ error: 'id column not found' });
  }

  let updated = 0;

  for (let i = 1; i < data.length; i++) {
    if (ids.includes(String(data[i][idIndex]))) {

      Object.keys(updates).forEach(key => {
        const col = headers.indexOf(key);
        if (col !== -1) {
          sheet.getRange(i + 1, col + 1).setValue(updates[key]);
        }
      });

      const lastUpdatedIndex = headers.indexOf('lastUpdated');
      if (lastUpdatedIndex !== -1) {
        sheet.getRange(i + 1, lastUpdatedIndex + 1)
          .setValue(nowJakarta());
      }

      appendHistory(headers, data[i], updates);
      updated++;
    }
  }

  return json({ success: true, updatedCount: updated });
}

// ---------- UPDATE REQUESTS ----------

function submitUpdateRequest(body) {
  const sheet = getRequestSheet();
  
  const timestamp = nowJakarta();
  const requestId = 'REQ-' + Utilities.formatDate(
    new Date(),
    "Asia/Jakarta",
    "yyyyMMddHHmmss"
  );
  
  sheet.appendRow([
    requestId,
    body.ids.join(','),
    JSON.stringify(body.updates),
    body.requestedBy,
    timestamp,
    'pending',
    body.isBatch ? 'batch' : 'single'
  ]);
  
  return json({ success: true, requestId: requestId });
}

function getPendingRequests() {
  const sheet = getRequestSheet();
  const data = sheet.getDataRange().getValues();
  const requests = [];
  
  for (let i = 1; i < data.length; i++) {
    if (data[i][5] === 'pending') {
      requests.push({
        requestId: data[i][0],
        ids: data[i][1].split(','),
        updates: JSON.parse(data[i][2]),
        requestedBy: data[i][3],
        timestamp: data[i][4],
        type: data[i][6]
      });
    }
  }
  
  return json(requests);
}

function approveRequest(body) {
  const requestSheet = getRequestSheet();
  const assetSheet = getSheet();
  
  const requestData = requestSheet.getDataRange().getValues();
  
  for (let i = 1; i < requestData.length; i++) {
    if (requestData[i][0] === body.requestId) {
      // Update request status
      requestSheet.getRange(i + 1, 6).setValue('approved');
      
      // Get the update details
      const ids = requestData[i][1].split(',');
      const updates = JSON.parse(requestData[i][2]);
      
      // Apply updates to assets
      const assetData = assetSheet.getDataRange().getValues();
      const headers = assetData[0];
      const idIndex = headers.indexOf('id');
      
      for (let j = 1; j < assetData.length; j++) {
        if (ids.includes(String(assetData[j][idIndex]))) {
          // Update each field
          Object.keys(updates).forEach(key => {
            const colIndex = headers.indexOf(key);
            if (colIndex !== -1 && updates[key]) {
              assetSheet.getRange(j + 1, colIndex + 1).setValue(updates[key]);
            }
          });
          
          // Update metadata
          const lastUpdatedIndex = headers.indexOf('lastUpdated');
          const updatedByIndex = headers.indexOf('updatedBy');
          
          if (lastUpdatedIndex !== -1) {
            assetSheet.getRange(j + 1, lastUpdatedIndex + 1).setValue(nowJakarta());
          }
          if (updatedByIndex !== -1) {
            assetSheet.getRange(j + 1, updatedByIndex + 1).setValue(body.approvedBy);
          }
          
          // Log to history
          appendHistory(headers, assetData[j], updates);
        }
      }
      break;
    }
  }
  
  return json({ success: true });
}

function rejectRequest(body) {
  const sheet = getRequestSheet();
  const requestData = sheet.getDataRange().getValues();
  
  for (let i = 1; i < requestData.length; i++) {
    if (requestData[i][0] === body.requestId) {
      sheet.getRange(i + 1, 6).setValue('rejected');
      break;
    }
  }
  
  return json({ success: true });
}

// ---------- DEBUG ----------

function debugHeaders() {
  const sheet = getSheet();
  Logger.log(sheet.getDataRange().getValues()[0]);
}