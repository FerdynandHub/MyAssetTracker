// ================================
// Dastrack - Google Apps Script Backend
// Sheet1 = current data (update only)
// Sheet2 = history log (append only)
// ================================

const SPREADSHEET_ID = '1uHTV9NX4mTrRGd-VTB_aIzMtfkuCUSu9-8JkfVvs2po';
const SHEET_NAME = 'Sheet1';
const HISTORY_SHEET_NAME = 'Sheet2';

// ---------- ENTRY POINTS ----------

function doGet(e) {
  try {
    const action = e.parameter.action;

    switch (action) {
      case 'getAssets':
        return getAssets();
      case 'getAsset':
        return getAssetById(e.parameter.id);
      case 'getCategories':
        return getCategories();
      default:
        return json({ error: 'Invalid action' });
    }
  } catch (err) {
    return json({ error: err.toString() });
  }
}

function doPost(e) {
  try {
    const body = JSON.parse(e.postData.contents);
    const action = body.action;

    switch (action) {
      case 'updateAsset':
        return updateAsset(body.id, body.updates);
      case 'batchUpdateAssets':
        return batchUpdateAssets(body.ids, body.updates);
      default:
        return json({ error: 'Invalid action' });
    }
  } catch (err) {
    return json({ error: err.toString() });
  }
}

// ---------- HELPERS ----------

function getSheet() {
  return SpreadsheetApp
    .openById(SPREADSHEET_ID)
    .getSheetByName(SHEET_NAME);
}

function getHistorySheet() {
  return SpreadsheetApp
    .openById(SPREADSHEET_ID)
    .getSheetByName(HISTORY_SHEET_NAME);
}

function json(data) {
  return ContentService
    .createTextOutput(JSON.stringify(data))
    .setMimeType(ContentService.MimeType.JSON);
}

function nowJakarta() {
  return Utilities.formatDate(
    new Date(),
    "Asia/Jakarta",
    "yyyy-MM-dd HH:mm:ss"
  );
}

function formatLastUpdated(value) {
  if (!value) return value;

  const d = (value instanceof Date)
    ? value
    : new Date(value);

  if (isNaN(d)) return value;

  return Utilities.formatDate(
    d,
    "Asia/Jakarta",
    "yyyy-MM-dd HH:mm:ss"
  );
}

// ---------- READ ----------

function getAssets() {
  const sheet = getSheet();
  const data = sheet.getDataRange().getValues();
  const headers = data[0];
  const assets = [];

  const lastUpdatedIndex = headers.indexOf('lastUpdated');

  for (let i = 1; i < data.length; i++) {
    const obj = {};

    headers.forEach((h, j) => {
      if (j === lastUpdatedIndex) {
        obj[h] = formatLastUpdated(data[i][j]);
      } else {
        obj[h] = data[i][j];
      }
    });

    assets.push(obj);
  }

  return json(assets);
}

function getAssetById(id) {
  if (!id) return json(null);

  const sheet = getSheet();
  const data = sheet.getDataRange().getValues();
  const headers = data[0];

  const idIndex = headers.indexOf('id');
  const lastUpdatedIndex = headers.indexOf('lastUpdated');

  if (idIndex === -1) {
    return json({ error: 'id column not found' });
  }

  for (let i = 1; i < data.length; i++) {
    if (String(data[i][idIndex]) === String(id)) {
      const asset = {};

      headers.forEach((h, j) => {
        if (j === lastUpdatedIndex) {
          asset[h] = formatLastUpdated(data[i][j]);
        } else {
          asset[h] = data[i][j];
        }
      });

      return json(asset);
    }
  }

  return json(null);
}

function getCategories() {
  const sheet = getSheet();
  const data = sheet.getDataRange().getValues();
  const headers = data[0];
  const categoryIndex = headers.indexOf('category');

  if (categoryIndex === -1) return json([]);

  const categories = [];

  for (let i = 1; i < data.length; i++) {
    const value = data[i][categoryIndex];
    if (value && !categories.includes(value)) {
      categories.push(value);
    }
  }

  return json(categories);
}

// ---------- HISTORY ----------

function appendHistory(headers, originalRow, updates) {
  const historySheet = getHistorySheet();

  const snapshot = headers.map((h, index) => {
    if (h === 'lastUpdated') {
      return nowJakarta();
    }
    if (updates.hasOwnProperty(h)) {
      return updates[h];
    }
    return originalRow[index];
  });

  historySheet.appendRow(snapshot);
}

// ---------- UPDATE ----------

function updateAsset(id, updates) {
  if (!id || !updates) {
    return json({ error: 'Invalid payload' });
  }

  const sheet = getSheet();
  const data = sheet.getDataRange().getValues();
  const headers = data[0];
  const idIndex = headers.indexOf('id');

  if (idIndex === -1) {
    return json({ error: 'id column not found' });
  }

  for (let i = 1; i < data.length; i++) {
    if (String(data[i][idIndex]) === String(id)) {

      Object.keys(updates).forEach(key => {
        const col = headers.indexOf(key);
        if (col !== -1) {
          sheet.getRange(i + 1, col + 1).setValue(updates[key]);
        }
      });

      const lastUpdatedIndex = headers.indexOf('lastUpdated');
      if (lastUpdatedIndex !== -1) {
        sheet.getRange(i + 1, lastUpdatedIndex + 1)
          .setValue(nowJakarta());
      }

      appendHistory(headers, data[i], updates);

      return json({ success: true });
    }
  }

  return json({ error: 'Asset not found' });
}

function batchUpdateAssets(ids, updates) {
  if (!Array.isArray(ids) || !updates) {
    return json({ error: 'Invalid payload' });
  }

  const sheet = getSheet();
  const data = sheet.getDataRange().getValues();
  const headers = data[0];
  const idIndex = headers.indexOf('id');

  if (idIndex === -1) {
    return json({ error: 'id column not found' });
  }

  let updated = 0;

  for (let i = 1; i < data.length; i++) {
    if (ids.includes(String(data[i][idIndex]))) {

      Object.keys(updates).forEach(key => {
        const col = headers.indexOf(key);
        if (col !== -1) {
          sheet.getRange(i + 1, col + 1).setValue(updates[key]);
        }
      });

      const lastUpdatedIndex = headers.indexOf('lastUpdated');
      if (lastUpdatedIndex !== -1) {
        sheet.getRange(i + 1, lastUpdatedIndex + 1)
          .setValue(nowJakarta());
      }

      appendHistory(headers, data[i], updates);
      updated++;
    }
  }

  return json({ success: true, updatedCount: updated });
}

// ---------- DEBUG ----------

function debugHeaders() {
  const sheet = getSheet();
  Logger.log(sheet.getDataRange().getValues()[0]);
}
