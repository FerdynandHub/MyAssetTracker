// ================================
// Dastrack - Google Apps Script Backend (SECURED)
// Sheet1 = current data (update only)
// Sheet2 = history log (append only)
// UpdateRequests = pending approval requests
// Users = user credentials (SECURED)
// Batteries = battery inventory
// BatteryHistory = battery checkout history
// ================================

const SPREADSHEET_ID = '1uHTV9NX4mTrRGd-VTB_aIzMtfkuCUSu9-8JkfVvs2po';
const SHEET_NAME = 'Sheet1';
const HISTORY_SHEET_NAME = 'Sheet2';
const REQUESTS_SHEET = 'UpdateRequests';

function debugAuthentication() {
  const sheet = getUsersSheet();
  const data = sheet.getDataRange().getValues();
  
  Logger.log('=== USERS SHEET DEBUG ===');
  Logger.log('Total rows: ' + data.length);
  Logger.log('Headers: ' + JSON.stringify(data[0]));
  Logger.log('First user row: ' + JSON.stringify(data[1]));
  
  // Check what's in the accessCode column
  const headers = data[0];
  const codeIndex = headers.indexOf('accessCode');
  Logger.log('accessCode column index: ' + codeIndex);
  Logger.log('Value in accessCode for row 2: "' + data[1][codeIndex] + '"');
  Logger.log('Type: ' + typeof data[1][codeIndex]);
  
  // Test the authenticate function directly
  Logger.log('=== TESTING AUTHENTICATE ===');
  const result = authenticate('123');
  Logger.log('Result: ' + JSON.stringify(result));
}

// ========== SECURITY: USER MANAGEMENT ==========

function getUsersSheet() {
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  let sheet = ss.getSheetByName('Users');
  
  if (!sheet) {
    sheet = ss.insertSheet('Users');
    sheet.appendRow(['accessCode', 'name', 'role', 'isActive', 'createdAt', 'lastLogin']);
    
    // Initialize with default users (DO THIS ONCE, then manage via sheet)
    sheet.appendRow(['123', 'Guest', 'viewer', 'TRUE', nowJakarta(), '']);
    sheet.appendRow(['ivan456', 'Ivan', 'editor', 'TRUE', nowJakarta(), '']);
    sheet.appendRow(['hien456', 'Hiendarta', 'editor', 'TRUE', nowJakarta(), '']);
    sheet.appendRow(['henny456', 'Henny', 'editor', 'TRUE', nowJakarta(), '']);
    sheet.appendRow(['alfons654', 'Alfons', 'editor', 'TRUE', nowJakarta(), '']);
    sheet.appendRow(['parmin456', 'Suparmin', 'editor', 'TRUE', nowJakarta(), '']);
    sheet.appendRow(['deni654', 'Denni', 'editor', 'TRUE', nowJakarta(), '']);
    sheet.appendRow(['111', 'ADMIN', 'admin', 'TRUE', nowJakarta(), '']);
    sheet.appendRow(['Mingming1234', 'Ferdynand', 'admin', 'TRUE', nowJakarta(), '']);
    sheet.appendRow(['dwiki123', 'Dwiki', 'editor', 'TRUE', nowJakarta(), '']);
    
    // IMPORTANT: Protect this sheet so only admins can edit
    const protection = sheet.protect();
    protection.setDescription('User credentials - Admin only');
  }
  
  return sheet;
}

// SECURITY: Authentication function
function authenticate(accessCode) {
  if (!accessCode) {
    return { success: false, message: 'Access code diperlukan' };
  }
  
  const sheet = getUsersSheet();
  const data = sheet.getDataRange().getValues();
  const headers = data[0];
  
  const codeIndex = headers.indexOf('accessCode');
  const nameIndex = headers.indexOf('name');
  const roleIndex = headers.indexOf('role');
  const activeIndex = headers.indexOf('isActive');
  const loginIndex = headers.indexOf('lastLogin');
  
  for (let i = 1; i < data.length; i++) {
    if (String(data[i][codeIndex]) === String(accessCode)) {
      // Check if account is active
      if (String(data[i][activeIndex]).toUpperCase() !== 'TRUE') {
        return { success: false, message: 'Akun tidak aktif. Hubungi administrator.' };
      }
      
      // Update last login time
      sheet.getRange(i + 1, loginIndex + 1).setValue(nowJakarta());
      
      // Log authentication attempt
      logAuthAttempt(data[i][nameIndex], true);
      
      return {
        success: true,
        name: data[i][nameIndex],
        role: data[i][roleIndex]
      };
    }
  }
  
  // Log failed attempt
  logAuthAttempt(accessCode, false);
  
  return { success: false, message: 'Kode akses tidak valid. Hubungi admin atau masuk sebagai guest (kode: 123)' };
}

// SECURITY: Log authentication attempts
function logAuthAttempt(identifier, success) {
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  let logSheet = ss.getSheetByName('AuthLog');
  
  if (!logSheet) {
    logSheet = ss.insertSheet('AuthLog');
    logSheet.appendRow(['timestamp', 'identifier', 'success', 'ipAddress']);
  }
  
  // Note: Google Apps Script doesn't provide IP address directly
  // You'd need to use UrlFetchApp to get this from an external service
  logSheet.appendRow([
    nowJakarta(),
    identifier,
    success ? 'SUCCESS' : 'FAILED',
    'N/A'
  ]);
  
  // Keep only last 1000 entries to prevent bloat
  if (logSheet.getLastRow() > 1001) {
    logSheet.deleteRow(2);
  }
}

// SECURITY: Add new user (admin only)
function addUser(adminCode, newAccessCode, name, role) {
  // Verify admin
  const adminAuth = authenticate(adminCode);
  if (!adminAuth.success || adminAuth.role !== 'admin') {
    return { success: false, message: 'Unauthorized' };
  }
  
  const sheet = getUsersSheet();
  
  // Check if user already exists
  const data = sheet.getDataRange().getValues();
  for (let i = 1; i < data.length; i++) {
    if (data[i][0] === newAccessCode) {
      return { success: false, message: 'Access code already exists' };
    }
  }
  
  sheet.appendRow([newAccessCode, name, role, 'TRUE', nowJakarta(), '']);
  return { success: true, message: 'User added successfully' };
}

// SECURITY: Deactivate user (admin only)
function deactivateUser(adminCode, targetAccessCode) {
  const adminAuth = authenticate(adminCode);
  if (!adminAuth.success || adminAuth.role !== 'admin') {
    return { success: false, message: 'Unauthorized' };
  }
  
  const sheet = getUsersSheet();
  const data = sheet.getDataRange().getValues();
  
  for (let i = 1; i < data.length; i++) {
    if (data[i][0] === targetAccessCode) {
      sheet.getRange(i + 1, 4).setValue('FALSE'); // isActive column
      return { success: true, message: 'User deactivated' };
    }
  }
  
  return { success: false, message: 'User not found' };
}

// ========== BATTERY MANAGEMENT ==========

function getBatterySheet() {
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  let sheet = ss.getSheetByName('Batteries');
  
  if (!sheet) {
    sheet = ss.insertSheet('Batteries');
    sheet.appendRow(['batteryType', 'quantity', 'lastUpdated']);
    
    // Initialize with default battery types
    sheet.appendRow(['AA', 0, nowJakarta()]);
    sheet.appendRow(['9V', 0, nowJakarta()]);
  }
  
  return sheet;
}

function getBatteryHistorySheet() {
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  let sheet = ss.getSheetByName('BatteryHistory');
  
  if (!sheet) {
    sheet = ss.insertSheet('BatteryHistory');
    sheet.appendRow(['batteryType', 'quantity', 'name', 'eventName', 'eventLocation', 'timestamp']);
  }
  
  return sheet;
}

function getBatteryHistory(limit) {
  const sheet = getBatteryHistorySheet();
  const data = sheet.getDataRange().getValues();
  const headers = data[0];
  
  // Skip header row and get all data
  const history = [];
  
  for (let i = 1; i < data.length; i++) {
    history.push({
      batteryType: data[i][0],
      quantity: data[i][1],
      name: data[i][2],
      eventName: data[i][3],
      eventLocation: data[i][4],
      timestamp: data[i][5]
    });
  }
  
  // Sort by timestamp descending (newest first)
  history.sort((a, b) => {
    const dateA = new Date(a.timestamp || 0);
    const dateB = new Date(b.timestamp || 0);
    return dateB - dateA;
  });
  
  // Limit results if specified
  const limitNum = parseInt(limit) || 10;
  const limitedHistory = history.slice(0, limitNum);
  
  return json({ history: limitedHistory });
}

function getBatteryInventory() {
  const sheet = getBatterySheet();
  const data = sheet.getDataRange().getValues();
  const headers = data[0];
  
  Logger.log('Battery Inventory Debug:');
  Logger.log('Headers: ' + JSON.stringify(headers));
  Logger.log('Total rows: ' + data.length);
  
  const typeIndex = headers.indexOf('batteryType');
  const qtyIndex = headers.indexOf('quantity');
  
  Logger.log('typeIndex: ' + typeIndex);
  Logger.log('qtyIndex: ' + qtyIndex);
  
  let inventory = { 'AA': 0, '9V': 0 };
  
  for (let i = 1; i < data.length; i++) {
    const type = String(data[i][typeIndex]).trim();
    const qty = Number(data[i][qtyIndex]) || 0;
    
    Logger.log('Row ' + i + ': type="' + type + '", qty=' + qty);
    
    if (type === 'AA' || type === '9V') {
      inventory[type] = qty;
    }
  }
  
  Logger.log('Final inventory: ' + JSON.stringify(inventory));
  
  return json({ inventory: inventory });
}

function checkoutBattery(body) {
  const { name, batteryType, quantity, eventName, eventLocation } = body;
  
  if (!name || !batteryType || !quantity || !eventName || !eventLocation) {
    return json({ error: 'Missing required fields' });
  }
  
  const sheet = getBatterySheet();
  const historySheet = getBatteryHistorySheet();
  
  // Update inventory
  const data = sheet.getDataRange().getValues();
  const headers = data[0];
  const typeIndex = headers.indexOf('batteryType');
  const qtyIndex = headers.indexOf('quantity');
  
  for (let i = 1; i < data.length; i++) {
    if (data[i][typeIndex] === batteryType) {
      const currentQty = Number(data[i][qtyIndex]) || 0;
      const newQty = currentQty + Number(quantity); // quantity is negative
      
      if (newQty < 0) {
        return json({ error: 'Insufficient inventory' });
      }
      
      sheet.getRange(i + 1, qtyIndex + 1).setValue(newQty);
      sheet.getRange(i + 1, headers.indexOf('lastUpdated') + 1).setValue(nowJakarta());
      break;
    }
  }
  
  // Log to history
  historySheet.appendRow([
    batteryType,
    quantity,
    name,
    eventName,
    eventLocation,
    nowJakarta()
  ]);
  
  return json({ success: true });
}

// ---------- ENTRY POINTS ----------

function doGet(e) {
  try {
    // Handle missing or undefined event parameter
    if (!e || !e.parameter) {
      return json({ 
        error: 'Missing parameters',
        message: 'This endpoint must be called via HTTP with parameters, not from the script editor',
        example: 'https://script.google.com/.../exec?action=authenticate&code=123'
      });
    }
    
    const action = e.parameter.action;

    switch (action) {
      case 'authenticate':
        return json(authenticate(e.parameter.code));
      case 'getAssets':
        return getAssets();
      case 'getAsset':
        return getAssetById(e.parameter.id);
      case 'getCategories':
        return getCategories();
      case 'getPendingRequests':
        return getPendingRequests();
      case 'getAssetHistory':
        return getAssetHistory(e.parameter.id);
      case 'getBatteryInventory':
        return getBatteryInventory();
        case 'getBatteryHistory':
  return getBatteryHistory(e.parameter.limit);
      case 'getMyRequests':  
        return json(getMyRequests(e.parameter.userName));
      default:
        return json({ error: 'Invalid action', availableActions: ['authenticate', 'getAssets', 'getAsset', 'getCategories', 'getPendingRequests', 'getAssetHistory', 'getBatteryInventory', 'getMyRequests'] });
    }
  } catch (err) {
    Logger.log('Error in doGet: ' + err.toString());
    return json({ error: 'Internal server error', details: err.toString() });
  }
}



function getPhotosFolder() {
  const folderName = 'Asset Photos - Portal AVM';
  const folders = DriveApp.getFoldersByName(folderName);
  
  if (folders.hasNext()) {
    return folders.next();
  } else {
    const folder = DriveApp.createFolder(folderName);
    folder.setSharing(DriveApp.Access.ANYONE_WITH_LINK, DriveApp.Permission.VIEW);
    return folder;
  }
}

function getMyRequests(userName) {
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  const requestsSheet = ss.getSheetByName(REQUESTS_SHEET);
  
  if (!requestsSheet) {
    Logger.log('UpdateRequests sheet not found');
    return [];
  }
  
  const data = requestsSheet.getDataRange().getValues();
  
  const requests = [];
  for (let i = 1; i < data.length; i++) {
    if (data[i][3] === userName) { // Column D is requestedBy
      // Parse IDs - split by comma if it's a string
      let ids = [];
      if (typeof data[i][1] === 'string') {
        ids = data[i][1].split(',').map(id => id.trim());
      }
      
      // Parse updates - it's already JSON
      let updates = {};
      try {
        updates = JSON.parse(data[i][2] || '{}');
      } catch (e) {
        Logger.log('Error parsing updates: ' + e);
        updates = {};
      }
      
      requests.push({
        requestId: data[i][0],      // Column A
        ids: ids,                   // Column B (parsed as array)
        updates: updates,           // Column C (JSON)
        requestedBy: data[i][3],    // Column D
        timestamp: data[i][4],      // Column E
        status: data[i][5] || 'pending',  // Column F
        type: data[i][6],           // Column G
        approvedBy: null
      });
    }
  }
  
  return requests.reverse();
}

function uploadPhoto(body) {
  try {
    const { fileName, base64Data, mimeType, assetId } = body;
    
    if (!fileName || !base64Data) {
      return json({ error: 'Missing fileName or base64Data' });
    }
    
    const folder = getPhotosFolder();
    
    const blob = Utilities.newBlob(
      Utilities.base64Decode(base64Data),
      mimeType || 'image/jpeg',
      fileName
    );
    
    // Delete old photos for this asset
    const existingFiles = folder.getFilesByName(fileName);
    while (existingFiles.hasNext()) {
      existingFiles.next().setTrashed(true);
    }
    
    const file = folder.createFile(blob);
    file.setSharing(DriveApp.Access.ANYONE_WITH_LINK, DriveApp.Permission.VIEW);
    
    const fileId = file.getId();
    const url = `https://drive.google.com/uc?export=view&id=${fileId}`;
    
    return json({
      success: true,
      url: url,
      fileId: fileId
    });
    
  } catch (error) {
    Logger.log('Error uploading photo: ' + error.toString());
    return json({ error: error.toString() });
  }
}

function doPost(e) {
  try {
    // Handle missing or undefined event parameter
    if (!e || !e.postData || !e.postData.contents) {
      return json({ 
        error: 'Missing POST data',
        message: 'This endpoint requires POST data with action parameter'
      });
    }

    const body = JSON.parse(e.postData.contents);
    const action = body.action;

    switch (action) {
      case 'updateAsset':
        return updateAsset(body.id, body.updates);
      case 'batchUpdateAssets':
        return batchUpdateAssets(body.ids, body.updates);
      case 'submitUpdateRequest':
        return submitUpdateRequest(body);
      case 'approveRequest':
        return approveRequest(body);
      case 'rejectRequest':
        return rejectRequest(body);
      case 'uploadPhoto':
        return uploadPhoto(body);
      case 'checkoutBattery':
        return checkoutBattery(body);
      case 'addUser':
        return json(addUser(body.adminCode, body.accessCode, body.name, body.role));
      case 'deactivateUser':
        return json(deactivateUser(body.adminCode, body.targetCode));
      default:
        return json({ error: 'Invalid action', availableActions: ['updateAsset', 'batchUpdateAssets', 'submitUpdateRequest', 'approveRequest', 'rejectRequest', 'uploadPhoto', 'checkoutBattery', 'addUser', 'deactivateUser'] });
    }
  } catch (err) {
    Logger.log('Error in doPost: ' + err.toString());
    return json({ error: 'Internal server error', details: err.toString() });
  }
}

// ---------- HELPERS ----------

function getSheet() {
  return SpreadsheetApp
    .openById(SPREADSHEET_ID)
    .getSheetByName(SHEET_NAME);
}

function getHistorySheet() {
  return SpreadsheetApp
    .openById(SPREADSHEET_ID)
    .getSheetByName(HISTORY_SHEET_NAME);
}

function getRequestSheet() {
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  let sheet = ss.getSheetByName('UpdateRequests');
  
  if (!sheet) {
    sheet = ss.insertSheet('UpdateRequests');
    sheet.appendRow(['requestId', 'ids', 'updates', 'requestedBy', 'timestamp', 'status', 'type']);
  }
  
  return sheet;
}

function json(data) {
  return ContentService
    .createTextOutput(JSON.stringify(data))
    .setMimeType(ContentService.MimeType.JSON);
}

function nowJakarta() {
  return Utilities.formatDate(
    new Date(),
    "Asia/Jakarta",
    "yyyy-MM-dd HH:mm:ss"
  );
}

function formatLastUpdated(value) {
  if (!value) return value;

  const d = (value instanceof Date)
    ? value
    : new Date(value);

  if (isNaN(d)) return value;

  return Utilities.formatDate(
    d,
    "Asia/Jakarta",
    "yyyy-MM-dd HH:mm:ss"
  );
}

// ---------- READ ----------

function getAssets() {
  const sheet = getSheet();
  const data = sheet.getDataRange().getValues();
  const headers = data[0];
  const assets = [];

  const lastUpdatedIndex = headers.indexOf('lastUpdated');

  for (let i = 1; i < data.length; i++) {
    const obj = {};

    headers.forEach((h, j) => {
      if (j === lastUpdatedIndex) {
        obj[h] = formatLastUpdated(data[i][j]);
      } else {
        obj[h] = data[i][j];
      }
    });

    assets.push(obj);
  }

  return json(assets);
}

function getAssetById(id) {
  if (!id) return json(null);

  const sheet = getSheet();
  const data = sheet.getDataRange().getValues();
  const headers = data[0];

  const idIndex = headers.indexOf('id');
  const lastUpdatedIndex = headers.indexOf('lastUpdated');

  if (idIndex === -1) {
    return json({ error: 'id column not found' });
  }

  for (let i = 1; i < data.length; i++) {
    if (String(data[i][idIndex]).toLowerCase() === String(id).toLowerCase()) {
      const asset = {};

      headers.forEach((h, j) => {
        if (j === lastUpdatedIndex) {
          asset[h] = formatLastUpdated(data[i][j]);
        } else {
          asset[h] = data[i][j];
        }
      });

      return json(asset);
    }
  }

  return json(null);
}

function getCategories() {
  const sheet = getSheet();
  const data = sheet.getDataRange().getValues();
  const headers = data[0];
  const categoryIndex = headers.indexOf('category');

  if (categoryIndex === -1) return json([]);

  const categories = [];

  for (let i = 1; i < data.length; i++) {
    const value = data[i][categoryIndex];
    if (value && !categories.includes(value)) {
      categories.push(value);
    }
  }

  return json(categories);
}

// ---------- HISTORY ----------

function appendHistory(headers, originalRow, updates) {
  const historySheet = getHistorySheet();

  const snapshot = headers.map((h, index) => {
    if (h === 'lastUpdated') {
      return nowJakarta();
    }
    if (updates.hasOwnProperty(h)) {
      return updates[h];
    }
    return originalRow[index];
  });

  historySheet.appendRow(snapshot);
}

function getAssetHistory(id) {
  if (!id) return json([]);

  const historySheet = getHistorySheet();
  const data = historySheet.getDataRange().getValues();
  const headers = data[0];
  const idIndex = headers.indexOf('id');

  if (idIndex === -1) {
    return json({ error: 'id column not found in history' });
  }

  const history = [];

  for (let i = 1; i < data.length; i++) {
    if (String(data[i][idIndex]).toLowerCase() === String(id).toLowerCase()) {
      const record = {};
      headers.forEach((h, j) => {
        if (h === 'lastUpdated' || h === 'timestamp') {
          record[h] = formatLastUpdated(data[i][j]);
        } else {
          record[h] = data[i][j];
        }
      });

      history.push(record);
    }
  }

  history.sort((a, b) => {
    const dateA = new Date(a.lastUpdated || 0);
    const dateB = new Date(b.lastUpdated || 0);
    return dateB - dateA;
  });

  return json(history);
}

// ---------- UPDATE ----------

function updateAsset(id, updates) {
  if (!id || !updates) {
    return json({ error: 'Invalid payload' });
  }

  const sheet = getSheet();
  const data = sheet.getDataRange().getValues();
  const headers = data[0];
  const idIndex = headers.indexOf('id');

  if (idIndex === -1) {
    return json({ error: 'id column not found' });
  }

  for (let i = 1; i < data.length; i++) {
    if (String(data[i][idIndex]).toLowerCase() === String(id).toLowerCase()) {

      Object.keys(updates).forEach(key => {
        const col = headers.indexOf(key);
        if (col !== -1) {
          sheet.getRange(i + 1, col + 1).setValue(updates[key]);
        }
      });

      const lastUpdatedIndex = headers.indexOf('lastUpdated');
      if (lastUpdatedIndex !== -1) {
        sheet.getRange(i + 1, lastUpdatedIndex + 1)
          .setValue(nowJakarta());
      }

      appendHistory(headers, data[i], updates);

      return json({ success: true });
    }
  }

  return json({ error: 'Asset not found' });
}

function batchUpdateAssets(ids, updates) {
  if (!Array.isArray(ids) || !updates) {
    return json({ error: 'Invalid payload' });
  }

  const sheet = getSheet();
  const data = sheet.getDataRange().getValues();
  const headers = data[0];
  const idIndex = headers.indexOf('id');

  if (idIndex === -1) {
    return json({ error: 'id column not found' });
  }

  const lowerIds = ids.map(id => String(id).toLowerCase());
  
  let updated = 0;

  for (let i = 1; i < data.length; i++) {
    if (lowerIds.includes(String(data[i][idIndex]).toLowerCase())) {

      Object.keys(updates).forEach(key => {
        const col = headers.indexOf(key);
        if (col !== -1) {
          sheet.getRange(i + 1, col + 1).setValue(updates[key]);
        }
      });

      const lastUpdatedIndex = headers.indexOf('lastUpdated');
      if (lastUpdatedIndex !== -1) {
        sheet.getRange(i + 1, lastUpdatedIndex + 1)
          .setValue(nowJakarta());
      }

      appendHistory(headers, data[i], updates);
      updated++;
    }
  }

  return json({ success: true, updatedCount: updated });
}

// ---------- UPDATE REQUESTS ----------

function submitUpdateRequest(body) {
  const sheet = getRequestSheet();
  
  const timestamp = nowJakarta();
  const requestId = 'REQ-' + Utilities.formatDate(
    new Date(),
    "Asia/Jakarta",
    "yyyyMMddHHmmss"
  );
  
  sheet.appendRow([
    requestId,
    body.ids.join(','),
    JSON.stringify(body.updates),
    body.requestedBy,
    timestamp,
    'pending',
    body.isBatch ? 'batch' : 'single'
  ]);
  
  return json({ success: true, requestId: requestId });
}

function getPendingRequests() {
  const sheet = getRequestSheet();
  const data = sheet.getDataRange().getValues();
  const requests = [];
  
  for (let i = 1; i < data.length; i++) {
    if (data[i][5] === 'pending') {
      requests.push({
        requestId: data[i][0],
        ids: data[i][1].split(','),
        updates: JSON.parse(data[i][2]),
        requestedBy: data[i][3],
        timestamp: data[i][4],
        type: data[i][6]
      });
    }
  }
  
  return json(requests);
}

function approveRequest(body) {
  const requestSheet = getRequestSheet();
  const assetSheet = getSheet();
  
  const requestData = requestSheet.getDataRange().getValues();
  
  for (let i = 1; i < requestData.length; i++) {
    if (requestData[i][0] === body.requestId) {
      requestSheet.getRange(i + 1, 6).setValue('approved');
      
      const ids = requestData[i][1].split(',');
      const updates = JSON.parse(requestData[i][2]);
      
      const assetData = assetSheet.getDataRange().getValues();
      const headers = assetData[0];
      const idIndex = headers.indexOf('id');
      
      const lowerIds = ids.map(id => String(id).toLowerCase());
      
      for (let j = 1; j < assetData.length; j++) {
        if (lowerIds.includes(String(assetData[j][idIndex]).toLowerCase())) {
          
          Object.keys(updates).forEach(key => {
            const colIndex = headers.indexOf(key);
            if (colIndex !== -1 && updates[key]) {
              assetSheet.getRange(j + 1, colIndex + 1).setValue(updates[key]);
            }
          });
          
          const lastUpdatedIndex = headers.indexOf('lastUpdated');
          const updatedByIndex = headers.indexOf('updatedBy');
          
          if (lastUpdatedIndex !== -1) {
            assetSheet.getRange(j + 1, lastUpdatedIndex + 1).setValue(nowJakarta());
          }
          if (updatedByIndex !== -1) {
            assetSheet.getRange(j + 1, updatedByIndex + 1).setValue(body.approvedBy);
          }
          
          const updatesWithUser = { ...updates, updatedBy: body.approvedBy };
          appendHistory(headers, assetData[j], updatesWithUser);
        }
      }
      break;
    }
  }
  
  return json({ success: true });
}

function rejectRequest(body) {
  const sheet = getRequestSheet();
  const requestData = sheet.getDataRange().getValues();
  
  for (let i = 1; i < requestData.length; i++) {
    if (requestData[i][0] === body.requestId) {
      sheet.getRange(i + 1, 6).setValue('rejected');
      break;
    }
  }
  
  return json({ success: true });
}


function testBatteryInventory() {
     Logger.log(getBatteryInventory());
   }